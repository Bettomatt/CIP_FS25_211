import pandas as pd
import glob
import os

#%%%
########################################################################################################
# Pre-processing
########################################################################################################
# Define the path and get all json files
# Use one of the following code, whatever is working.
path = "data/clean-dataset/"
# path = "../data/clean-dataset/"
all_files = glob.glob(os.path.join(path, "clean_*.json"))

# Read all files and concatenate into one DataFrame
dfs = []
for file in all_files :
    # Each JSON file contains one JSON per line
    df = pd.read_json(file, lines=True)
    dfs.append(df)

data = pd.concat(dfs, ignore_index=True)

# Convert date columns to datetime objects
data['date'] = pd.to_datetime(data['date'])
data['planned_arrival'] = pd.to_datetime(data['planned_arrival'])
data['real_arrival'] = pd.to_datetime(data['real_arrival'])

# Preview the data
# print(data.head())
# summary = data.describe()

########################################################################################################
# Use IQR (Interquartile Range) Method to filter out statistical outliers.

def remove_outliers(df, col, multiplier=1.5):
    # Remove outliers from a DataFrame column based on the IQR method.
    q1 = df[col].quantile(0.25)
    q3 = df[col].quantile(0.75)
    iqr = q3 - q1
    lower_bound = q1 - multiplier * iqr
    upper_bound = q3 + multiplier * iqr
    return df[(df[col] >= lower_bound) & (df[col] <= upper_bound)]

# Use the function to remove outliers in arrival_delay_min
data_clean_iqr = remove_outliers(data, 'arrival_delay_min')

"""
# Optional: Inspect the cleaned data statistics
print("\nAfter cleaning with IQR:")
print(data_clean_iqr['arrival_delay_min'].describe())

# Create a boxplot grouped by date
plt.figure(figsize=(12,6))
data_clean_iqr.boxplot(column='arrival_delay_min', by='date', grid=False)
plt.title("Arrival Delay per Day (IQR Cleaned Data)")
plt.xlabel("Date")
plt.ylabel("Arrival Delay (min)")
plt.xticks(rotation=45)
plt.suptitle('')  # Removes the default subtitle generated by pandas
plt.tight_layout()
plt.show()
"""
# Clean identified columns from NaN values
# print(data_clean_iqr[['arrival_delay_min', 'temperature_2m', 'precipitation', 'snowfall', 'wind_speed_10m', 'cloudcover', 'weathercode']].isna().sum())
"""
Example:
arrival_delay_min        0
temperature_2m       10283
precipitation        10283
snowfall             10283
wind_speed_10m       10283
cloudcover           10283
weathercode          10283
"""
data_no_nan = data_clean_iqr.dropna(subset=['arrival_delay_min', 'temperature_2m', 'precipitation', 'snowfall', 'wind_speed_10m', 'cloudcover', 'weathercode'])
# %%% Create new variables (categorical bins) for plotting

# Precipitation bins in mm (adjust as needed).
# Bin labels must be one fewer than the number of bin edges
bins = [0, 0.02, 0.04, 0.06, 0.08, 0.1, 0.12, 0.14]
labels = ['0-0.02 mm', '0.02-0.04 mm', '0.04-0.06 mm', '0.06-0.08 mm', '0.08-0.10 mm', '0.10-0.12 mm', '0.12-0.14+ mm']

# Create categorical bins
data_no_nan = data_no_nan.copy()
data_no_nan.loc[:, 'precipitation_category'] = pd.cut(
    data_no_nan['precipitation'],
    bins=bins,
    labels=labels,
    include_lowest=True
)
# Snowfall bins in cm (adjust as needed).
# Bin labels must be one fewer than the number of bin edges
bins = [-0.01, 0, 0.1, 0.5, 1, 2, 5]
labels = ['0 cm', '0-0.1 cm', '0.1-0.5 cm', '0.5-1 cm', '1-2 cm', '2-5 cm']

# Create categorical bins
data_no_nan = data_no_nan.copy()
data_no_nan.loc[:, 'snowfall_category'] = pd.cut(
    data_no_nan['snowfall'],
    bins=bins,
    labels=labels,
    include_lowest=True
)
########################################################################################################
# Extracts the day of the week as a new column
data_no_nan['weekday'] = data_no_nan['date'].dt.day_name()

# Create new columns for month name and month number (to preserve order)
data_no_nan['month'] = data_no_nan['date'].dt.strftime('%B')
data_no_nan['month_num'] = data_no_nan['date'].dt.month
########################################################################################################
# Add original Weather Code description
"""
Weather condition is a numeric code. See table below for details.
WMO Weather interpretation codes (WW)
Code	    Description
0	        Clear sky
1,  2,  3	Mainly clear, partly cloudy, and overcast
45, 48	    Fog and depositing rime fog
51, 53, 55	Drizzle: Light, moderate, and dense intensity
56, 57	    Freezing Drizzle: Light and dense intensity
61, 63, 65	Rain: Slight, moderate and heavy intensity
66, 67	    Freezing Rain: Light and heavy intensity
71, 73, 75	Snow fall: Slight, moderate, and heavy intensity
77	        Snow grains
80, 81, 82	Rain showers: Slight, moderate, and violent
85, 86	    Snow showers slight and heavy
95 *	    Thunderstorm: Slight or moderate
96, 99 *	Thunderstorm with slight and heavy hail
(*) Thunderstorm forecast with hail is only available in Central Europe
"""
# Define the mapping for weather codes to descriptions
weather_mapping = {
    0: "Clear sky",
    1: "Mainly clear, partly cloudy, and overcast",
    2: "Mainly clear, partly cloudy, and overcast",
    3: "Mainly clear, partly cloudy, and overcast",
    45: "Fog and depositing rime fog",
    48: "Fog and depositing rime fog",
    51: "Drizzle: Light, moderate, and dense intensity",
    53: "Drizzle: Light, moderate, and dense intensity",
    55: "Drizzle: Light, moderate, and dense intensity",
    56: "Freezing Drizzle: Light and dense intensity",
    57: "Freezing Drizzle: Light and dense intensity",
    61: "Rain: Slight, moderate and heavy intensity",
    63: "Rain: Slight, moderate and heavy intensity",
    65: "Rain: Slight, moderate and heavy intensity",
    66: "Freezing Rain: Light and heavy intensity",
    67: "Freezing Rain: Light and heavy intensity",
    71: "Snow fall: Slight, moderate, and heavy intensity",
    73: "Snow fall: Slight, moderate, and heavy intensity",
    75: "Snow fall: Slight, moderate, and heavy intensity",
    77: "Snow grains",
    80: "Rain showers: Slight, moderate, and violent",
    81: "Rain showers: Slight, moderate, and violent",
    82: "Rain showers: Slight, moderate, and violent",
    85: "Snow showers slight and heavy",
    86: "Snow showers slight and heavy",
    95: "Thunderstorm: Slight or moderate",
    96: "Thunderstorm with slight and heavy hail",
    99: "Thunderstorm with slight and heavy hail"
}

# Map the weather codes to their descriptions
data_no_nan['orig_weather_description'] = data_no_nan['weathercode'].map(weather_mapping)

# Optionally, if there might be codes not covered by the mapping, assign 'Unknown'
data_no_nan['orig_weather_description'] = data_no_nan['orig_weather_description'].fillna('Unknown')

#function to get dataframe from other files in scripts
def get_data_no_nan ():
    return data_no_nan

########################################################################################################
# Add simplified Weather Code description
def simplified_weather(code):
    if code == 0:
        return "Clear"
    elif code in [1, 2, 3]:
        return "Cloudy"
    elif code in [45, 48]:
        return "Fog"
    elif code in [51, 53, 55, 56, 57]:
        return "Drizzle"
    elif code in [61, 63, 65, 66, 67]:
        return "Rain"
    elif code in [71, 73, 75, 77, 85, 86]:
        return "Snow"
    elif code in [95, 96, 99]:
        return "Thunderstorm"
    else:
        return "Unknown"

data_no_nan['simp_weather_description'] = data_no_nan['weathercode'].apply(simplified_weather)

# %%% for data_no_nan2

# Does not limit the upper boundaries
def remove_outliers2(df, col, multiplier=1.5):
    # Remove outliers from a DataFrame column based on the IQR method.
    q1 = df[col].quantile(0.25)
    q3 = df[col].quantile(0.75)
    iqr = q3 - q1
    lower_bound = q1 - multiplier * iqr
    upper_bound = df[col].max()  # Use df[col].max() to work with the provided DataFrame
    return df[(df[col] >= lower_bound) & (df[col] <= upper_bound)]

# Use the function to remove outliers in arrival_delay_min
data_clean_iqr2 = remove_outliers2(data, 'arrival_delay_min')

data_no_nan2 = data_clean_iqr2.dropna(subset=['arrival_delay_min', 'temperature_2m', 'precipitation', 'snowfall', 'wind_speed_10m', 'cloudcover', 'weathercode'])

# %%%
# Precipitation bins in mm (adjust as needed).
# Bin labels must be one fewer than the number of bin edges

# Create categorical bins
data_no_nan2 = data_no_nan2.copy()
data_no_nan2.loc[:, 'precipitation_category'] = pd.cut(
    data_no_nan2['precipitation'],
    bins=bins,
    labels=labels,
    include_lowest=True
)
# Snowfall bins in cm (adjust as needed).

# Create categorical bins
data_no_nan2 = data_no_nan2.copy()
data_no_nan2.loc[:, 'snowfall_category'] = pd.cut(
    data_no_nan2['snowfall'],
    bins=bins,
    labels=labels,
    include_lowest=True
)
########################################################################################################
# Extracts the day of the week as a new column
data_no_nan2['weekday'] = data_no_nan2['date'].dt.day_name()

# Create new columns for month name and month number (to preserve order)
data_no_nan2['month'] = data_no_nan2['date'].dt.strftime('%B')
data_no_nan2['month_num'] = data_no_nan2['date'].dt.month
########################################################################################################
# Add original Weather Code description

# Map the weather codes to their descriptions
data_no_nan2['orig_weather_description'] = data_no_nan2['weathercode'].map(weather_mapping)

# Optionally, if there might be codes not covered by the mapping, assign 'Unknown'
data_no_nan2['orig_weather_description'] = data_no_nan2['orig_weather_description'].fillna('Unknown')

def get_data_no_nan2 ():
    return data_no_nan2
########################################################################################################
# Add simplified Weather Code description

data_no_nan2['simp_weather_description'] = data_no_nan2['weathercode'].apply(simplified_weather)

#%%% Store dataframe
# Define the target directory
path1 = "data/final_data"

# Save the dataframes to CSV files in the target folder
data_no_nan2.to_csv(os.path.join(path1, "data_no_nan2.csv"), index=False)
data_no_nan.to_csv(os.path.join(path1, "data_no_nan.csv"), index=False)
